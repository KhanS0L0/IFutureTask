# Исследование многопоточного сервиса

## Цель
Создание многопоточного сервиса и оценка его производительности.

## Функционал сервиса
Сервис должен хранить, обновлять и получать значение банковского счёта по указанному идентификатору используя следующий интерфейс:

```java
    /**
     * Интерфейс сервиса для работы с банковским счётом содержит два метода
     **/
    interface BalanceService {
        /**
        *  Получение баланса
        *
        *  @param id идентификатор банковского счёта
        *  @return сумма денег на банковском счёте
        */
        Optional<Long> getBalance(Long id);

        /**
        *  Изменение баланса на определённое значение
        *
        *  @param id идентификатор банковского счёта
        *  @param value сумма денег, которую нужно добавить к банковскому счёту
        */
        void changeBalance(Long id, Long amount);
    }
```

### Требования к функционалу сервиса
* Сервис должен сохранять состояние счетов в базе данных.
* Нужно предусмотреть кэширование данных.
* Сервис должен работать в многопоточном режиме и корректно обрабатывать параллельные запросы, в том числе к одному банковскому счёту.
* Предполагается, что метод getBalance учитывает результаты всех успешно завершившихся ранее методов changeBalance.
* Сервис должен быть максимально высокопроизводительным, т.е. обрабатывать как можно большее количество запросов в единицу времени. 

## Оценка производительности
На стороне сервиса нужно подсчитывать количество запросов getBalance, changeBalance и их сумму в единицу времени. Результат записывать в лог.

Для оценки производительности сервиса нужно реализовать клиента, который в несколько потоков выполняет бесконечный цикл. В цикле выполняется случайно выбранный запрос getBalance или changeBalance. Параметры для этих запросов выбираются из списка также случайным образом.

Требуются следующие настройки:

```
threadCount - количество клиентских потоков (>= 1)
readQuota   - доля запросов getBalance (>= 0)
writeQuota  - доля запросов changeBalance (>= 0)
readIdList  - список идентификаторов для getBalance
writeIdList - список идентификаторов для changeBalance
```
Пример использования:

```java
    new Thread (() -> {
        ...
        while (true) {
            // вероятность вызова метода getBalance
            double readProbability = (double)readQuota/(double)(readQuota+writeQuota);

            if (ThreadLocalRandom.current().nextDouble() < readProbability) {
                getBalance(randomFromList(readIdList));
            } else {
                changeBalance(randomFromList(writeIdList), 1L);
            }
        }
        ...
    })
```

### Требования к инструментарию
* Java или Kotlin любой версии
* Использование или не использование SpringBoot’а и других framework’ов не принципиально
* Можно использовать любые библиотеки
* Можно использовать любые базы данных, брокеры сообщений и прочие сервисы
* Можно использовать любые протоколы общения между клиентом и сервером (http, hessian, rest, grpc, netty, rmi, socket’ы)